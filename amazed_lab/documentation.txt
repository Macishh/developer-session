Documentation - Amazed (Group 14)

Our solution is similar to the Sequential solution, but we spawn multiple threads and sum up their work in the end. 
For each thread we spawn a player, that explores the maze. Each thread also has a list with children (the threads that 
thread spawned), and a thread is spawned when the parent thread has moved forkAfter steps.

The reason why this solution works is dependent on what each thread is returning from the method. If a thread has found 
the goal, it returns the path from that threads start to the goal. If the goal was not found it returns null. So when a 
parent thread is done, and did not find the goal, we loop through each child that parent spawned and check if any of the 
children have found the goal. If the goal was found by a child, we add and return their path from start -> goal with our 
path from start -> the start point of the child. This process is used until we have reached the starting thread which 
then returns the complete path, from start (0, 0) to the goal.

When we loop through the children of a parent, we get the value with child.join(). This means that the parent can only 
get the value of the return if the child is done, which means that we wait until the child is done and will therefore 
make sure that all the returns from the children are checked.

This is the reason to why our solution works, and will aways do! :D